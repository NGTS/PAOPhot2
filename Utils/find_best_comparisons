#!/home/sam/anaconda3/bin/python

# To avoid OpenBLAS error
import os
os.environ['OPENBLAS_NUM_THREADS'] = '1'

# Imports
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import argparse, os, sys
from astropy.table import Table 
import numpy as np 
from scipy.ndimage import median_filter
import matplotlib.gridspec as gridspec

# Tmag limit for bright objects
# RMS VS Mag (against the mean)
# bin to 5 minutes
# Find highest pixel in aperture
# all targets 40 pixels down to T 14 
# all out to 2 aperture izes, then all within 




# Arg parser
def arg_parse():
    """
    Parse the command line arguments
    """
    p = argparse.ArgumentParser("Reduce whole actions.")
    p.add_argument('photometery_catalogue',
                   help='The photometry catalogue from which to  ',
                   type=str)
    p.add_argument('photometry_file',
                   help='The action photometry file for which to create the best comparisons with. ',
                   type=str)
    p.add_argument('--output_dir',
                   help='The output directory.',
                   type=str, default = '.')
    return p.parse_args()



# Main loop
if __name__=="__main__":
    # First, pars the arguments
    args = arg_parse()
    print('Finding best candidates for {:} using {:}'.format(args.photometery_catalogue.split('/')[-1], args.photometry_file.split('/')[-1]))

    # Now load the photoemtry file, and get the comparison photometry, colnames
    photometry_file = Table.read(args.photometry_file, format='csv')
    photometery_catalogue = Table.read(args.photometery_catalogue)

    # Now get the target information and comparison information
    target_row = photometery_catalogue[photometery_catalogue['PAOPHOT_IDX']==0]
    comparison_table = photometery_catalogue[photometery_catalogue['PAOPHOT_IDX']==2] 
    negative_flux_comp_mask = np.zeros(len(comparison_table), dtype = np.bool)
    for i in range(len(comparison_table)):
        if np.median( photometry_file['TIC-{:}_Aper_flux_3'.format(comparison_table['tic_id'][i])] ) < 0 : negative_flux_comp_mask[i] = True
        if np.sum(photometry_file['TIC-{:}_Aper_flux_3'.format(comparison_table['tic_id'][i])]/(3**2*np.pi) > 50000) > 50 : negative_flux_comp_mask[i] = True # catches saturated stars
    tic_ids = np.array(['TIC-{:}'.format(i) for i in comparison_table['tic_id']]) 

    # Now lets get the flux columns
    print('Extracting target and comparison fluxes')
    target_flux = np.array(photometry_file['TIC-{:}_Aper_flux_3'.format(target_row['tic_id'][0])])
    comparison_flux = np.zeros((len(comparison_table) , len(photometry_file)))
    for i in range(len(comparison_table)) : comparison_flux[i]  = photometry_file['TIC-{:}_Aper_flux_3'.format(comparison_table['tic_id'][i])]
    x = np.arange(comparison_flux.shape[0]) # indexes of each comparison star

    print('Calcualting raw flux standard deviations for each comparison')
    # Now calcualte the STD / MEDIAN for each comparison star
    STD_MEDIAN_RAW = np.zeros(comparison_flux.shape[0])
    for i in range(comparison_flux.shape[0]) : STD_MEDIAN_RAW[i] = np.std(comparison_flux[i]) / np.median(comparison_flux[i])
    STD_MEDIAN_to_clip = np.copy(STD_MEDIAN_RAW)

    # Now iteratavily reject comparison stars
    n_reject, i = 1e6 , 1
    while n_reject > 0:
        med_noise = np.median(STD_MEDIAN_to_clip)
        mad_noise = np.median(np.abs(STD_MEDIAN_to_clip-med_noise))
        mask_sig = np.where((STD_MEDIAN_to_clip < med_noise + 4*mad_noise))[0]
        n_reject = len(STD_MEDIAN_to_clip) - len(mask_sig)
        STD_MEDIAN_to_clip = np.copy(STD_MEDIAN_to_clip[mask_sig]) 
        print('\tIteration {:<2,} rejected {:<3,} comparisons out of {:<3,}'.format(i, n_reject, STD_MEDIAN_RAW.shape[0]))
        i+=1
    mask_rawflux =(STD_MEDIAN_RAW > (med_noise + 4*mad_noise)) | (STD_MEDIAN_RAW < 0)  # need to chec kif flux is zero for some reason, look at this!!!!

    print('Calcualting comparison flux standard deviations for each comparison')
    STD_MEDIANS_COMP = np.zeros((comparison_flux.shape[0], comparison_flux.shape[0]))
    for i in range(comparison_flux.shape[0]):
        for j in range(comparison_flux.shape[0]):
            if (i!=j):
                FLUX_RATIO = comparison_flux[i] / comparison_flux[j]
                STD_MEDIANS_COMP[i,j] =  np.std(FLUX_RATIO) / np.median(FLUX_RATIO)

    XX, YY = np.meshgrid(x, x)
    STD_MEDIANS_COMP_plot = np.copy(STD_MEDIANS_COMP)
    STD_MEDIANS_COMP_plot[x[mask_rawflux | negative_flux_comp_mask], :] = 0.
    STD_MEDIANS_COMP_plot[:, x[mask_rawflux | negative_flux_comp_mask]] = 0.

    xcomp = np.arange(comparison_flux.shape[0])[~(mask_rawflux | negative_flux_comp_mask)] # indexes of each comparison star
    signal = (np.mean(STD_MEDIANS_COMP_plot, axis=0)[~(mask_rawflux | negative_flux_comp_mask)] + np.mean(STD_MEDIANS_COMP_plot, axis=1)[~(mask_rawflux | negative_flux_comp_mask)] )/2
    trend =  median_filter(signal,5)
    trend = np.poly1d(np.polyfit(xcomp,trend,2))(xcomp)
    detrended_signal = signal /trend

    # Now iteratavily reject comparison stars
    STD_MEDIAN_to_clip = np.copy(detrended_signal)
    n_reject, i = 1e6 , 1
    while n_reject > 0:
        med_noise = np.median(STD_MEDIAN_to_clip)
        mad_noise = np.median(np.abs(STD_MEDIAN_to_clip-med_noise))
        mask_sig = np.where((STD_MEDIAN_to_clip < med_noise + 4*mad_noise))[0]
        n_reject = len(STD_MEDIAN_to_clip) - len(mask_sig)
        STD_MEDIAN_to_clip = np.copy(STD_MEDIAN_to_clip[mask_sig]) 
        print('\tIteration {:<2,} rejected {:<3,} comparisons out of {:<3,}'.format(i, n_reject, detrended_signal.shape[0]))
        i+=1
    mask_compflux =(detrended_signal > (med_noise + 4*mad_noise))
    mask_compfluxratio = np.zeros(comparison_flux.shape[0], dtype = np.bool)
    counter = 0
    for i in range(mask_compfluxratio.shape[0]):
        if (not mask_rawflux[i]):
            if (mask_compflux[counter]) : mask_compfluxratio[i] = True
            counter += 1

        


    # Now we have two masks ready to use, mask_rawflux and mask_compfluxratio

    f = plt.figure(constrained_layout=True, figsize=(15,10))
    spec2 = gridspec.GridSpec(ncols=2, nrows=2, figure=f)
    axs=[]
    axs.append(f.add_subplot(spec2[0, :]))
    axs.append(f.add_subplot(spec2[1, 0]))
    axs.append(f.add_subplot(spec2[1, 1]))

    axs[0].semilogy(x[~negative_flux_comp_mask], STD_MEDIAN_RAW[~negative_flux_comp_mask], c='k')
    twinx = axs[0].twinx()
    twinx.semilogy(x[~(negative_flux_comp_mask | mask_rawflux)], (np.sum(STD_MEDIANS_COMP_plot, axis=0) + np.sum(STD_MEDIANS_COMP_plot, axis=1))[~(negative_flux_comp_mask | mask_rawflux)],  c='g')
    axs[0].set(ylim = (0,None), xlabel='Comparison star\n[<-- RANK]', ylabel=r'$\sum \sigma_{F}$ / $\widetilde{F}$')
    axs[0].vlines(x[negative_flux_comp_mask | mask_rawflux | mask_compfluxratio], ymin = np.zeros(x.shape[0])[negative_flux_comp_mask | mask_rawflux | mask_compfluxratio], ymax = STD_MEDIAN_RAW[negative_flux_comp_mask | mask_rawflux | mask_compfluxratio], color='r', label='Rejected stars due to high raw flux variation')
    axs[0].set_xticks(x)
    axs[0].set_xticklabels(tic_ids, rotation = 60, fontsize=4, ha="right")
    plt.legend()

    axs[1].imshow(STD_MEDIANS_COMP_plot, vmin = 0.0, vmax = np.max(STD_MEDIANS_COMP_plot), aspect='auto')
    axs[1].set(xlabel='Comparison star\n[<-- RANK]', ylabel='Comparison star\n[<-- RANK]', title='Comparison star ratio rejection')
    axs[1].set_xticks(x)
    axs[1].set_xticklabels(tic_ids, rotation = 60, fontsize=2, ha="right")
    axs[1].set_yticks(x)
    axs[1].set_yticklabels(tic_ids, rotation = 60, fontsize=2, ha="right")

    axs[2].scatter(xcomp, signal, c='k')
    axs[2].scatter(xcomp[mask_compflux], signal[mask_compflux], c='r')
    axs[2].plot(xcomp, trend, c='r', label='Trend')
    axs[2].set(xlabel='Comparison star\n[<-- RANK]', ylabel=r'$\sum \sigma_{F}$ / $\widetilde{F}$', title='Target : TIC-{:}'.format(target_row['tic_id'][0]))
    axs[2].set_xticks(xcomp)
    axs[2].set_xticklabels(tic_ids[~mask_rawflux], rotation = 30, fontsize=5, ha="right")

    f.savefig('{:}/TIC-{:}_Comparison_star_rejection.png'.format(args.output_dir, target_row['tic_id'][0]), dpi=250)
    plt.close()

    
    # now write it out for photmerge
    mask_table = Table([~(negative_flux_comp_mask | mask_rawflux | mask_compfluxratio)], names = ['MASK'])
    mask_table.write('{:}/{:}_mask.fits'.format(args.output_dir, args.photometery_catalogue.split('/')[-1][:-5]), format='fits', overwrite=True)

    f = plt.figure()
    plt.scatter(comparison_table['Tmag'][~(negative_flux_comp_mask | mask_rawflux | mask_compfluxratio)],STD_MEDIAN_RAW[~(negative_flux_comp_mask | mask_rawflux | mask_compfluxratio)], c='k' )
    plt.xlabel('Tmag')
    plt.ylabel(r'$\sigma_{F}$ / $\widetilde{F}$')
    f.savefig('{:}/{:}_Comparison_star_RMS.png'.format(args.output_dir, target_row['tic_id'][0]), dpi=250)
    plt.close()