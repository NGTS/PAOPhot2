#!/home/sam/anaconda3/bin/python

# Imports
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt

import argparse, os, sys
from PAOPhot2.db import is_action_ready_to_reduce, get_action_info , get_images_information_for_action, get_image_information, PAOPhot_paths , get_autoguider_information
from PAOPhot2.make_photometry_catalogue import make_TIC_target_catalogue
from PAOPhot2.time_conversion import convert_MJD
from PAOPhot2.plot_functions import plot_target_night
from astropy.io import fits 
from multiprocessing import Pool 
from astropy.table import Table 
import numpy as np 


# PAOphot path

# Arg parser
def arg_parse():
    """
    Parse the command line arguments
    """
    p = argparse.ArgumentParser("Reduce whole actions.")
    p.add_argument('action',
                   help='The action ID',
                   type=str)

    p.add_argument('-b', 
                '--photometry_catalogue',
                help='The catalogue file for which to extract photometry with. If None, we will use the reference catalogue associate with the reference image.',
                default='None', type=str)

    p.add_argument('-c', 
                '--target_ticid',
                help='The TIC ID of the target for which to extract photometry for. ',
                default='-1', type=int)        


    p.add_argument('-d', 
                '--threads',
                help='The number of processing threads [default= 2]',
                default=2, type=int)
                   
        
    return p.parse_args()




def photometry_worker(i):
    #image_path = '/ngts/das01/action254027_observeField/IMAGE81120200928093346.fits.bz2'
    image_path = '/ngts/das{:02}/action{:}_observeField/IMAGE{:}.fits.bz2'.format(action_info['das_id'], 
                                                                                    args.action, 
                                                                                    images_information[i]['image_id'])
    if not os.path.isfile(image_path) :
        print('Unable to find {:}'.format(image_path))

    else:
        # Create the WCSPhot command
        cmd = '/usr/local/anaconda3/bin/python {:}/wcsphotpipe.py {:} {:} {:} {:} --outdir {:} --dont_save_image'.format(PAOPhot_paths['WCSPhotpipe_path'],
                                                                                                image_path,
                                                                                                solved_autoguider_image_location,
                                                                                                solved_autoguider_catalogue_location,
                                                                                                photometry_catalogue,
                                                                                                output_directory)
        print(cmd) 
        os.system(cmd)

        # Now compress this 
        cmd = 'gzip -fv {:}/IMAGE{:}.phot'.format(output_directory, images_information[i]['image_id'])
        #print(cmd)
        #os.system(cmd)

# Main loop
if __name__=="__main__":
    # First, pars the arguments
    args = arg_parse()

    # Now get the action status
    status = is_action_ready_to_reduce(args.action)
    if status : print('Reducing action {:}'.format(args.action))
    else      : print('Action  {:} is not ready to reduce.'.format(args.action))
    
    # Get the action information
    action_info = get_action_info(args.action) 
    print('\tDetails:')
    for key in action_info.keys(): print('\t\t{:<15} : {:}'.format(key, action_info[key])) 

    # Now check for AG reference image with valid WCS
    print('\tAutoguider information')
    autoguider_image_information = get_autoguider_information(action_info['field'], action_info['camera_id'])
    for key in autoguider_image_information.keys(): print('\t\t{:<15} : {:}'.format(key, autoguider_image_information[key])) 

    # Now check for AG reference image catalogue from which we will generate the image WCS
    print('\tChecking to see if autotguider image has been solved... ', end='')
    solved_autoguider_image_location = '{:}/autotguider_images_and_catalogue/{:}'.format(PAOPhot_paths['PAOPhot2_data_path'], autoguider_image_information['filename'])
    solved_autoguider_catalogue_location = '{:}/autotguider_images_and_catalogue/{:}'.format(PAOPhot_paths['PAOPhot2_data_path'], autoguider_image_information['filename'][:-5] + '_reference_catalogue.fits')

    if True: #not os.path.isfile(solved_autoguider_catalogue_location) or not os.path.isfile(solved_autoguider_image_location):
        print(' No autoguider products found, running refcatpipe2')
        # We havent got the solved autoguider reference image with a stamped WCS solution
        # Lets call refcatpipe2 and save it here.

        # First, lets get the  autoguider_obstart for calcualtion of proper motion in the catalogue.
        autoguider_obstart = fits.open('/ngts/autoguider_ref/' + autoguider_image_information['filename'])[0].header['OBSSTART']
        
        # First make the reference catalogue
        cmd = '/usr/local/anaconda3/bin/python {:}/make_ref_catalog.py {:} {:} 3.0 3.0 "{:}" "{:}"'.format(PAOPhot_paths['refcatpipe2_path'], 
                                                                                   action_info['ra_target_deg'], 
                                                                                   action_info['dec_target_deg'], 
                                                                                   autoguider_obstart , 
                                                                                   solved_autoguider_catalogue_location )
        print(cmd)
        #os.system(cmd) 

        # Check the catalogue has been made
        if not os.path.isfile(solved_autoguider_catalogue_location) : 
            print('Attempted to make the reference catalogue but failed.')
            exit()


        # Now solve the autoguider reference image for a WCS solution 
        cmd = '/usr/local/anaconda3/bin/python {:}/solve_ref_images.py {:} {:} --indir {:} --outdir {:}'.format(PAOPhot_paths['refcatpipe2_path'], 
                                                                                        solved_autoguider_catalogue_location, 
                                                                                        autoguider_image_information['filename'], 
                                                                                        '/ngts/autoguider_ref',  
                                                                                        '{:}/autotguider_images_and_catalogue'.format(PAOPhot_paths['PAOPhot2_data_path']))
        print(cmd)
        #os.system(cmd) 

        # Finally, we need to estimate what the dilution is for each target in the frame using NGTSDilution
        cmd = '/usr/local/anaconda3/bin/python {:}/ngtsdilution.py {:} {:} --output_dir {:} --threads {:} --prf_data {:}'.format(PAOPhot_paths['NGTSDilution_path'],
                                                                        solved_autoguider_image_location,
                                                                        solved_autoguider_catalogue_location,
                                                                        '{:}/autotguider_images_and_catalogue'.format(PAOPhot_paths['PAOPhot2_data_path']),
                                                                        args.threads,
                                                                        '{:}/NGTS_PRF/NG0029-3024_813_IMAGE81320191012010055_cat.npy'.format(PAOPhot_paths['NGTSDilution_path']))
        print(cmd)
        #os.system(cmd) 


        # If we are here, we should have both the catalogue and the solve WCS image in our directiory. 
        # Lets check
        print('\t\tValidating refcatpipe2 outputs... ')
        REFCATPIPE2_ERROR = False
        if not os.path.isfile(solved_autoguider_catalogue_location) :
            print('\t\tCould not find {:}'.format(solved_autoguider_catalogue_location))
            REFCATPIPE2_ERROR = True 
        if not os.path.isfile(solved_autoguider_image_location) :
            print('\t\tCould not find {:}'.format(solved_autoguider_image_location))
            REFCATPIPE2_ERROR = True 
        if REFCATPIPE2_ERROR : 
            print('\t\tError with refcatpipe2, one or more outputs missing. Check logs. ')
            exit() 
        else : print('refcatpipe2 ran OK')
    else : print('Products found.')


    # Now check the photometry catalogue, using thr reference catalogue as a failsafe
    if args.photometry_catalogue == 'None': 
        if args.target_ticid != -1:
            # Here we need to check if the photometry catalogue has been made
            # This is a unique catalogue with the format   NGXXXX+YY_TICXXXXXXXX.fits
            # stored in PAOPhot2/target_catalogues/NGXXXX+YY_TICXXXXXXXX.fits 
            # Now we need to check to see if the photometry catalogue exists
            # If not, we need to make it 
            photometry_catalogue = '{:}/target_catalogues/TIC-{:}.fits'.format(PAOPhot_paths['PAOPhot2_data_path'], args.target_ticid)
            if not os.path.isfile(photometry_catalogue) : 
                print('Not found {:}, making it.'.format(photometry_catalogue))
                make_TIC_target_catalogue(args.target_ticid, solved_autoguider_image_location, solved_autoguider_catalogue_location).write(photometry_catalogue, overwrite=True)
            else:
                print('Found {:}'.format(photometry_catalogue))
        else : photometry_catalogue = solved_autoguider_catalogue_location
    else : photometry_catalogue = args.photometry_catalogue


    # Get the image information associated with this action
    # list of dictionaries, not disctionary of lists
    images_information = get_images_information_for_action(args.action)
    print('\t\tFound information for {:,} science images'.format(len(images_information)))

    # Create the output directory 
    output_directory = '{:}/photometry/action{:}'.format(PAOPhot_paths['PAOPhot2_data_path'], args.action)
    os.system('mkdir -p {:}'.format(output_directory))

    # loop over the images, running WCSPhot for each 
    #for i in range(len(images_information))[:5]:
    #pool = Pool(args.threads)
    #pool.map(photometry_worker, range(len(images_information))[:])
    #pool.close()
    #pool.join()




    print('\tImage reduction complete. Counting number of photfiles. ')
    reduced_mask = np.zeros(len(images_information), dtype=np.bool)
    for i in range(len(images_information)):
        image_path = '/ngts/das{:02}/action{:}_observeField/IMAGE{:}.fits.bz2'.format(action_info['das_id'], 
                                                                                        args.action, 
                                                                                        images_information[i]['image_id'])
        phot_file = '{:}/IMAGE{:}.phot'.format(output_directory,
                                                images_information[i]['image_id'])

        if os.path.isfile(phot_file) : reduced_mask[i] = True
        else : print('\t\t{:} failed to reduce'.format(image_path))


    print('\tSummary')
    print('\t\t{:,} frames reduced out of {:,} frames [{:.2f} %]'.format(np.sum(reduced_mask), len(images_information), 100*np.sum(reduced_mask)/len(images_information) ))
    
    # Trime the image info to only the used ones
    images_information = np.array(images_information)[reduced_mask]


    print('Now concating the table')
    target_table = Table.read(photometry_catalogue)   #tic_id contains the names 

    # First, make the total table to hold all the photometry.
    # We need to make sure headers are correct here, and contain a column for each target
    table_header = ['JD', 'BJD', 'HJD']
    photometry_header = Table.read('{:}/IMAGE{:}.phot'.format(output_directory, images_information[0]['image_id'])).colnames[1:]
    for i in range(len(target_table)):
        for j in range(len(photometry_header)) : table_header.append('TIC-{:}_{:}'.format(str(target_table['tic_id'][i]), photometry_header[j]))
    table_dtype = np.tile(float,len(table_header))
    total_table = Table(names=table_header, dtype=table_dtype) 


    for i in range(len(images_information))[:100]:
        phot_file = '{:}/IMAGE{:}.phot'.format(output_directory, images_information[i]['image_id'])
        print('Collecting {:} [{:,} out of {:,}]'.format(phot_file.split('/')[-1], i+1, len(images_information)))
        phot_table = Table.read(phot_file)
        phot_table.remove_column('Sequence_number') # we dont need or account for this 

        # First, get the time
        JD, BJD, HJD = convert_MJD(images_information[i]['mjd'], phot_table['hjd_corr_sec'][0], phot_table['bjd_corr_sec'][0]) # do this only for target
        row = [JD.jd,  BJD.jd,  HJD.jd]

        data = np.zeros((len(phot_table), len(phot_table.colnames)), dtype = np.float64)
        for j in range(len(phot_table.colnames)) : data[:,j] = np.array(phot_table[phot_table.colnames[j]], dtype = np.float64) 
        data = data.flatten() 
        data = np.concatenate((np.array(row), data))
        total_table.add_row(data)

    # Now plot the night 
    print('Now plottting night...')
    f, ax, date = plot_target_night(total_table , 'TIC-{:}'.format(args.target_ticid) )

    print('Writing table')
    total_table.write('{:}/TIC-{:}_{:}_photometry.csv'.format(output_directory, args.target_ticid, date), overwrite=True, format='csv')

    f.savefig('{:}/TIC-{:}_{:}.png'.format(output_directory, args.target_ticid, date))
    plt.close(f) 